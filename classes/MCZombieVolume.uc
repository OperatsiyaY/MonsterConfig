class MCZombieVolume extends ZombieVolume;//--------------------------------------------------------------------------------------------------// UMZombieVolume maked runtime, so brush loosed, so we just copy spawnpoints, no need InitSpawnPointsfunction InitSpawnPoints();//--------------------------------------------------------------------------------------------------//Experimental volume for spawning squads of zombies.function bool SpawnInHere( out array< class<KFMonster> > zombies, optional bool test,    optional out int numspawned, optional out int TotalMaxMonsters, optional int MaxMonstersAtOnceLeft,    optional out int TotalZombiesValue, optional bool bTryAllSpawns ){	local int i,l,j,zc,yc;	local KFMonster Act;	local byte fl;	local rotator RandRot;	local vector TrySpawnPoint;	local int NumTries;		log("UMZombieVolume SpawnInHere");		/* First make sure there are any zombie types allowed to spawn in here */	l = zombies.Length;	zc = DisallowedZeds.Length;	yc = OnlyAllowedZeds.Length;	for( i=0; i<l; i++ )	{		fl = zombies[i].Default.ZombieFlag;		if( (!bNormalZeds && fl==0) || (!bRangedZeds && fl==1) || (!bLeapingZeds && fl==2) || (!bMassiveZeds && fl==3) )			goto'RemoveEntry';		if( zc==0 && yc==0 )			continue;		for( j=0; j<zc; j++ )			if( ClassIsChildOf(zombies[i],DisallowedZeds[j]) )				goto'RemoveEntry';		if( yc>0 )		{			for( j=0; j<yc; j++ )				if( ClassIsChildOf(zombies[i],OnlyAllowedZeds[j]) )					goto'LoopEnd';RemoveEntry:			zombies.Remove(i,1);			l--;			i--;		}LoopEnd:	}	if( l==0 )		return false;	if( !test )	{		if( ZombieCountMulti<1 )			zombies.Length = Max(zombies.Length*ZombieCountMulti,1); // Decrease the size.		else if( ZombieCountMulti>1 )		{			// Increase the size and scramble zombie spawn types.			zombies.Length = Max(zombies.Length*(ZombieCountMulti/2+ZombieCountMulti*FRand()),zombies.Length);			l = zombies.Length;			for( i=0; i<l; i++ )				if( zombies[i]==None )					zombies[i] = zombies[Rand(i)];		}		if( zombies.Length==0 )			return false;	}	/* Now do the actual spawning */	if( !test )	{		l = zombies.Length;		for( i=0; i<l; i++ )		{			if( TotalMaxMonsters>0 && MaxMonstersAtOnceLeft>0) // Always make sure we are allowed to spawn em.			{				RandRot.Yaw = Rand(65536);                if( bTryAllSpawns )                {                    // Try spawning in all the points                    NumTries = SpawnPos.Length;                }                else                {                    // Try spawning 3 times in 3 dif points.                    NumTries = 3;                }                for( j=0; j<NumTries; j++ )		        {                    TrySpawnPoint = SpawnPos[Rand(SpawnPos.Length)];    				if( !PlayerCanSeePoint(TrySpawnPoint, zombies[i]) )    				{                        //Act = Spawn(zombies[i],,,TrySpawnPoint,RandRot);						Act = Spawn(class'KFChar.ZombieBloat_XMas',,,TrySpawnPoint,RandRot);                    }                    else                    {                        if( bDebugZoneSelection )                        {                            log("Failed trying to spawn "$zombies[i]$" attempt "$j);                        }                        continue;                    }    				if(Act!=None)    				{    				     // Triggers & Event Tracking    				    /* ========================================================================*/						if(ZombieSpawnTag != '')						{							Act.Tag = ZombieSpawnTag ;						}						if(ZombieDeathEvent != '')						{							Act.Event = ZombieDeathEvent;						}                        AddZEDToSpawnList(Act);						/*==========================================================================*/                        if( bDebugSpawnSelection )                        {                            DrawDebugCylinder(Act.Location,vect(1,0,0),vect(0,1,0),vect(0,0,1),Act.CollisionRadius,Act.CollisionHeight,5,0, 255, 0);                        }    					if( bDebugZoneSelection )    					{                            log("Spawned "$zombies[i]$" on attempt "$j);                        }                        break;    				}				}				if(Act!=None)				{					TotalMaxMonsters--;					MaxMonstersAtOnceLeft--;					numspawned++;					TotalZombiesValue += Act.ScoringValue;				}			}		}		if( numspawned>0 )		{            LastSpawnTime = Level.TimeSeconds;            LastFailedSpawnTime = 0;            return true;		}		else		{            LastFailedSpawnTime = Level.TimeSeconds;            return false;		}	}	return true;}defaultproperties{	bStatic=false	bNoDelete=false}